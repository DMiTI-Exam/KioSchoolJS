import{Utils}from"../utils/Utils.js";import{Globals}from"../utils/Global.js";import{Vertex}from"./Vertex.js";import{Edge}from"./Edge.js";export class Graph{#edges=[];#vertices=[];constructor(){let innerPointsRays=Utils.randomSubset(Utils.range(0,Globals.RAYS_COUNT),Utils.rnd(Math.floor(Globals.RAYS_COUNT/3),Math.ceil(Globals.RAYS_COUNT/2))).sort();let innerSegmentsRays=Utils.randomSubset(innerPointsRays,Utils.rnd(Math.floor(innerPointsRays.length/2),innerPointsRays.length-1)).sort();let outerPointsRays=Utils.randomSubset(Utils.range(0,Globals.RAYS_COUNT),Utils.rnd(Math.floor(Globals.RAYS_COUNT/3),Math.ceil(Globals.RAYS_COUNT/2))).sort();let center=new Vertex(0,0);let innerCircle=[];let middleCircle=[];let outerCircle=[];for(let i=0;i<Globals.RAYS_COUNT;i++){let r3=Globals.RAY_LENGTH[i];let r1=Utils.rnd(Globals.MIN_INNER_SEGMENT_SIZE,Globals.MAX_INNER_SEGMENT_SIZE);let r2=Utils.rnd(Globals.MIN_OUTER_SEGMENT_START,r3-Globals.MIN_OUTER_SEGMENT_SIZE);let v2=new Vertex(i,r2);middleCircle.push(v2);if(innerPointsRays.indexOf(i)!==-1){let v1=new Vertex(i,r1);innerCircle.push(v1);if(innerSegmentsRays.indexOf(i)!==-1){this.#edges.push(new Edge(center,v1))}this.#edges.push(new Edge(v1,v2))}if(outerPointsRays.indexOf(i)!==-1){let v3=new Vertex(i,r3);outerCircle.push(v3);this.#edges.push(new Edge(v2,v3))}}this.#vertices.push(center);for(let ver of innerCircle){this.#vertices.push(ver)}for(let ver of middleCircle){this.#vertices.push(ver)}for(let ver of outerCircle){this.#vertices.push(ver)}for(let i=0;i<innerCircle.length;i++){let j=i===0?innerCircle.length-1:i-1;this.#edges.push(new Edge(innerCircle[j],innerCircle[i]))}for(let i=0;i<middleCircle.length;i++){let j=i===0?middleCircle.length-1:i-1;this.#edges.push(new Edge(middleCircle[j],middleCircle[i]))}this.#edges=this.#edges.sort((a,b)=>a.lengthGetter()-b.lengthGetter())}edgesGetter(){return this.#edges}verticesGetter(){return this.#vertices}isLastEdgeExistsGetter(){let isExist=false;for(let e of this.#edges){if(e.lastGetter()===Edge.LAST_TRUE){isExist=true;break}}return isExist}lastEdgeGetter(){let res;let isExist=false;for(let e of this.#edges){if(e.lastGetter()===Edge.LAST_TRUE){res=e;isExist=true;break}}return res}}